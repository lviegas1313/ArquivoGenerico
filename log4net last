// === Arquivo Único: Log4NetLogger.cs ===
using log4net;
using log4net.Config;
using log4net.Core;
using log4net.Util;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Collections.Concurrent;
using System.IO;
using System.Reflection;

public sealed class Log4NetSettings
{
    public required string ConfigFilePath { get; set; }
    public required string LogLevel { get; set; }
    public required string LogFilePath { get; set; }
    public required int MaxFileSizeMB { get; set; }
    public required int MaxBackupFiles { get; set; }
}

public static class Log4NetExtensions
{
    public static ILoggingBuilder AddCustomLog4Net(
        this ILoggingBuilder builder,
        IConfiguration configuration)
    {
        // Registrar configurações
        builder.Services.Configure<Log4NetSettings>(configuration.GetSection("Log4NetSettings"));
        
        // Registrar provedor
        builder.Services.AddSingleton<ILoggerProvider, Log4NetLoggerProvider>();
        
        return builder;
    }

    private sealed class Log4NetLoggerProvider(
        IOptionsMonitor<Log4NetSettings> settings) : ILoggerProvider
    {
        private readonly ConcurrentDictionary<string, Log4NetLogger> _loggers = new();
        private bool _isConfigured;

        public ILogger CreateLogger(string categoryName)
        {
            return _loggers.GetOrAdd(categoryName, name =>
            {
                EnsureInitialized(settings.CurrentValue);
                return new Log4NetLogger(name, settings);
            });
        }

        private void EnsureInitialized(Log4NetSettings config)
        {
            if (_isConfigured) return;
            
            lock (typeof(Log4NetLoggerProvider))
            {
                if (_isConfigured) return;

                GlobalContext.Properties["LogFilePath"] = config.LogFilePath;
                GlobalContext.Properties["MaxFileSize"] = $"{config.MaxFileSizeMB}MB";
                GlobalContext.Properties["MaxBackupFiles"] = config.MaxBackupFiles;

                var logRepository = LogManager.GetRepository(Assembly.GetEntryAssembly());
                XmlConfigurator.Configure(logRepository, new FileInfo(config.ConfigFilePath));
                
                logRepository.Threshold = ConvertLogLevel(config.LogLevel);
                EnsureLogDirectory(config.LogFilePath);
                
                _isConfigured = true;
            }
        }

        private static void EnsureLogDirectory(string logFilePath)
        {
            var logDirectory = Path.GetDirectoryName(logFilePath);
            if (!Directory.Exists(logDirectory))
                Directory.CreateDirectory(logDirectory!);
        }

        private static Level ConvertLogLevel(string logLevel) => logLevel.ToUpper() switch
        {
            "TRACE" => Level.Trace,
            "DEBUG" => Level.Debug,
            "INFORMATION" => Level.Info,
            "WARNING" => Level.Warn,
            "ERROR" => Level.Error,
            "CRITICAL" => Level.Fatal,
            _ => Level.Info
        };

        public void Dispose() => _loggers.Clear();
    }

    private sealed class Log4NetLogger(
        string categoryName,
        IOptionsMonitor<Log4NetSettings> settings) : ILogger
    {
        private readonly ILog _log = LogManager.GetLogger(Assembly.GetEntryAssembly(), categoryName);

        public IDisposable BeginScope<TState>(TState state) where TState : notnull => NullScope.Instance;

        public bool IsEnabled(LogLevel logLevel) => logLevel >= ConvertLogLevel(settings.CurrentValue.LogLevel);

        public void Log<TState>(
            LogLevel logLevel,
            EventId eventId,
            TState state,
            Exception? exception,
            Func<TState, Exception?, string> formatter)
        {
            if (!IsEnabled(logLevel)) return;

            var message = formatter(state, exception);
            var log4NetLevel = ConvertLevel(logLevel);
            
            _log.Logger.Log(new LoggingEvent(
                new LoggingEventData
                {
                    Level = log4NetLevel,
                    Message = message,
                    ExceptionString = exception?.ToString(),
                    LoggerName = _log.Logger.Name,
                    TimeStamp = DateTime.Now,
                    Properties = new PropertiesDictionary()
                }));
        }

        private static Level ConvertLevel(LogLevel logLevel) => logLevel switch
        {
            LogLevel.Trace => Level.Trace,
            LogLevel.Debug => Level.Debug,
            LogLevel.Information => Level.Info,
            LogLevel.Warning => Level.Warn,
            LogLevel.Error => Level.Error,
            LogLevel.Critical => Level.Fatal,
            _ => Level.Info
        };

        private static LogLevel ConvertLogLevel(string logLevel) => logLevel.ToUpper() switch
        {
            "TRACE" => LogLevel.Trace,
            "DEBUG" => LogLevel.Debug,
            "INFORMATION" => LogLevel.Information,
            "WARNING" => LogLevel.Warning,
            "ERROR" => LogLevel.Error,
            "CRITICAL" => LogLevel.Critical,
            _ => LogLevel.Information
        };
    }
}
// === Fim do Arquivo ===

// === Uso no Program.cs ===
var builder = WebApplication.CreateBuilder(args);

// Configuração essencial
builder.Configuration.AddJsonFile("log4net.config.json");
builder.Logging.AddCustomLog4Net(builder.Configuration); // Chamada correta

var app = builder.Build();
app.Run();

builder.Services.AddSingleton<ILoggerProvider, Log4NetLoggerProvider>();

public static ILoggingBuilder AddCustomLog4Net(this ILoggingBuilder builder, IConfiguration configuration)
