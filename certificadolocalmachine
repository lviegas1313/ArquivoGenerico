Sem problemas! Vou refatorar mantendo a classe `CertificateSettings` como uma **classe tradicional** e ajustar apenas o `SslCertificateHandler`. Aqui est√° a solu√ß√£o:

---

### 1. Classe `CertificateSettings` (Original + Novas Propriedades)

```csharp
public class CertificateSettings
{
    public string Path { get; set; }               // Mantido para uso local
    public string Passphrase { get; set; }         // Mantido para uso local
    public string StoreLocation { get; set; }      // Novo: "LocalMachine" ou "CurrentUser"
    public string StoreName { get; set; }          // Novo: Ex: "My", "Root", etc.
    public string SubjectDistinguishedName { get; set; } // Novo: Ex: "CN=example.com, OU=TI, O=Empresa"
}
```

---

### 2. Classe `SslCertificateHandler` Refatorada

```csharp
using System.Security.Cryptography.X509Certificates;

public class SslCertificateHandler : HttpClientHandler
{
    public SslCertificateHandler(CertificateSettings settings)
    {
        if (IsServerConfiguration(settings))
        {
            ConfigureFromStore(settings);
        }
        else
        {
            ConfigureFromFile(settings);
        }
    }

    private bool IsServerConfiguration(CertificateSettings settings)
    {
        return !string.IsNullOrEmpty(settings.StoreLocation) &&
               !string.IsNullOrEmpty(settings.StoreName) &&
               !string.IsNullOrEmpty(settings.SubjectDistinguishedName);
    }

    private void ConfigureFromStore(CertificateSettings settings)
    {
        var storeLocation = Enum.Parse<StoreLocation>(settings.StoreLocation);
        var storeName = Enum.Parse<StoreName>(settings.StoreName);

        using (var store = new X509Store(storeName, storeLocation))
        {
            store.Open(OpenFlags.ReadOnly);
            var certificates = store.Certificates.Find(
                X509FindType.FindBySubjectDistinguishedName,
                settings.SubjectDistinguishedName,
                validOnly: true // Certificados v√°lidos (n√£o expirados)
            );

            ValidateCertificate(certificates, $"Subject DN: {settings.SubjectDistinguishedName}");
            ClientCertificates.Add(certificates[0]);
        }
    }

    private void ConfigureFromFile(CertificateSettings settings)
    {
        var certificate = new X509Certificate2(settings.Path, settings.Passphrase);
        ValidateCertificate(new X509Certificate2Collection { certificate }, $"Path: {settings.Path}");
        ClientCertificates.Add(certificate);
    }

    private void ValidateCertificate(X509Certificate2Collection certificates, string searchCriteria)
    {
        if (certificates.Count == 0)
            throw new InvalidOperationException($"Certificado n√£o encontrado. Crit√©rio: {searchCriteria}");

        var cert = certificates[0];
        if (cert.NotAfter < DateTime.Now)
            throw new InvalidOperationException($"Certificado expirado em {cert.NotAfter:dd/MM/yyyy}");
    }
}
```

---

### 3. Configura√ß√£o no `appsettings.json`

#### Ambiente Local (Configura√ß√£o Original):
```json
"CertificateSettings": {
    "Path": "certs/local-cert.pfx",
    "Passphrase": "senha123"
}
```

#### Servidor (Nova Configura√ß√£o):
```json
"CertificateSettings": {
    "StoreLocation": "LocalMachine",
    "StoreName": "My",
    "SubjectDistinguishedName": "CN=api.production.com, OU=Security, O=Company"
}
```

---

### Principais Pontos da Refatora√ß√£o:

1. **Respeito √† Classe Original:**  
   - A classe `CertificateSettings` permanece uma classe tradicional com propriedades p√∫blicas.

2. **L√≥gica de Carregamento de Certificado:**  
   - **Ambiente Local:** Usa `Path` e `Passphrase` para carregar o certificado de um arquivo.
   - **Servidor:** Usa `StoreLocation`, `StoreName`, e `SubjectDistinguishedName` para buscar no reposit√≥rio de certificados.

3. **Valida√ß√£o de Expira√ß√£o:**  
   - Verifica se o certificado est√° expirado em ambos os cen√°rios.

4. **Mensagens de Erro Claras:**  
   - Indica qual crit√©rio de busca falhou e se o certificado est√° expirado.

---

### Uso no `Program.cs` (Inalterado):

```csharp
builder.Services.AddHttpClient()
    .ConfigurePrimaryHttpMessageHandler(sp => 
    {
        var settings = sp.GetRequiredService<IOptions<CertificateSettings>>().Value;
        return new SslCertificateHandler(settings);
    });
```

---

### Testes de Valida√ß√£o:

1. **Certificado N√£o Encontrado no Servidor:**
   ```csharp
   var settings = new CertificateSettings 
   { 
       StoreLocation = "LocalMachine", 
       StoreName = "My", 
       SubjectDistinguishedName = "CN=inexistente.com" 
   };
   Assert.Throws<InvalidOperationException>(() => new SslCertificateHandler(settings));
   ```

2. **Certificado Expirado:**
   ```csharp
   var settings = new CertificateSettings 
   { 
       Path = "certs/expired-cert.pfx", 
       Passphrase = "senha123" 
   };
   Assert.Throws<InvalidOperationException>(() => new SslCertificateHandler(settings));
   ```

Esta solu√ß√£o mant√©m a compatibilidade com a configura√ß√£o original e adiciona a funcionalidade necess√°ria para o servidor, tudo dentro dos princ√≠pios SOLID. üòä


## Solu√ß√£o: Encapsular a Convers√£o em `CertificateSettings`

Para centralizar a valida√ß√£o e convers√£o, podemos adicionar propriedades √† classe `CertificateSettings` que retornam os enums diretamente. Isso mant√©m a configura√ß√£o limpa e evita repeti√ß√£o de c√≥digo.

#### 1. Classe `CertificateSettings` Atualizada:

```csharp
using System.Security.Cryptography.X509Certificates;

public class CertificateSettings
{
    // Propriedades originais (para appsettings.json)
    public string Path { get; set; }
    public string Passphrase { get; set; }
    public string StoreLocation { get; set; } // Ex: "LocalMachine"
    public string StoreName { get; set; }     // Ex: "My"
    public string SubjectDistinguishedName { get; set; }

    // Propriedades computadas (para uso interno)
    public StoreLocation StoreLocationEnum => 
        Enum.Parse<StoreLocation>(StoreLocation);

    public StoreName StoreNameEnum => 
        Enum.Parse<StoreName>(StoreName);
}
```

---

#### 2. Atualiza√ß√£o no `SslCertificateHandler`:

```csharp
private void ConfigureFromStore(CertificateSettings settings)
{
    using var store = new X509Store(settings.StoreNameEnum, settings.StoreLocationEnum);
    store.Open(OpenFlags.ReadOnly);

    var certificates = store.Certificates.Find(
        X509FindType.FindBySubjectDistinguishedName,
        settings.SubjectDistinguishedName,
        validOnly: true
    );

    ValidateCertificate(certificates, $"Subject DN: {settings.SubjectDistinguishedName}");
    ClientCertificates.Add(certificates[0]);
}
```

---

### Vantagens:

1. **Centraliza√ß√£o da L√≥gica:**  
   A convers√£o de `string` para `enum` fica encapsulada na classe `CertificateSettings`.

2. **Valida√ß√£o Impl√≠cita:**  
   Qualquer valor inv√°lido em `StoreLocation` ou `StoreName` lan√ßar√° uma exce√ß√£o durante o parsing, facilitando o debug.

3. **Mantenha a Configura√ß√£o como String:**  
   O arquivo `appsettings.json` continua usando strings leg√≠veis (ex: `"LocalMachine"`), que s√£o convertidas para enums apenas no c√≥digo.

4. **Reusabilidade:**  
   Qualquer outra classe que precise desses valores pode usar as propriedades `StoreLocationEnum` e `StoreNameEnum` diretamente.

---

### Configura√ß√£o no `appsettings.json` (Inalterada):

```json
"CertificateSettings": {
    "StoreLocation": "LocalMachine",
    "StoreName": "My",
    "SubjectDistinguishedName": "CN=api.example.com"
}
```

---

### Tratamento de Erros (Opcional):

Para melhorar a experi√™ncia, voc√™ pode adicionar valida√ß√£o expl√≠cita:

```csharp
public class CertificateSettings
{
    // ... (outras propriedades)

    public void Validate()
    {
        if (!Enum.TryParse<StoreLocation>(StoreLocation, out _))
            throw new ArgumentException($"StoreLocation inv√°lido: {StoreLocation}");

        if (!Enum.TryParse<StoreName>(StoreName, out _))
            throw new ArgumentException($"StoreName inv√°lido: {StoreName}");
    }
}

// Uso:
var settings = new CertificateSettings();
settings.Validate(); // Lan√ßa exce√ß√£o se houver valores inv√°lidos
```

---

### Conclus√£o

Ao encapsular a convers√£o dentro da pr√≥pria classe `CertificateSettings`, voc√™ mant√©m o c√≥digo limpo, adere ao **SOLID** (especialmente o **Single Responsibility Principle**) e facilita futuras modifica√ß√µes. üòä
